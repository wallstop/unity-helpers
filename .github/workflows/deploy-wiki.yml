name: Deploy Documentation to GitHub Wiki

"on":
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      force_sync:
        description: "Force sync even if no changes detected"
        required: false
        default: "false"
        type: boolean
      dry_run:
        description: "Dry run - show changes without pushing"
        required: false
        default: "false"
        type: boolean

permissions:
  contents: write

# Prevent concurrent wiki pushes to avoid git conflicts
concurrency:
  group: wiki-sync
  cancel-in-progress: false

env:
  WIKI_URL: "https://github.com/${{ github.repository }}.wiki.git"

jobs:
  # First job: Check if wiki exists before attempting sync
  check-wiki:
    name: Check wiki availability
    runs-on: ubuntu-latest
    outputs:
      wiki_exists: ${{ steps.check.outputs.wiki_exists }}
    steps:
      - name: Check if wiki repository exists
        id: check
        run: |
          set -euo pipefail
          echo "Checking wiki availability at: $WIKI_URL"

          # Use git ls-remote for lightweight check (no clone needed)
          if git ls-remote "$WIKI_URL" HEAD >/dev/null 2>&1; then
            echo "âœ… Wiki repository exists"
            echo "wiki_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "::warning::Wiki repository not found at $WIKI_URL"
            echo "::warning::To enable wiki sync:"
            echo "::warning::  1. Go to repository Settings â†’ Features"
            echo "::warning::  2. Enable 'Wikis'"
            echo "::warning::  3. Create at least one wiki page manually"
            echo "::warning::  4. Re-run this workflow"
            echo "wiki_exists=false" >> "$GITHUB_OUTPUT"
          fi

  # Second job: Sync documentation to wiki (only if wiki exists)
  sync-wiki:
    name: Sync documentation to wiki
    needs: check-wiki
    if: needs.check-wiki.outputs.wiki_exists == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main repository
        uses: actions/checkout@v4
        with:
          path: main
          fetch-depth: 1

      - name: Clone wiki repository
        id: clone-wiki
        run: |
          set -euo pipefail
          echo "Cloning wiki repository..."

          WIKI_AUTH_URL="https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.wiki.git"

          if ! git clone "$WIKI_AUTH_URL" wiki 2>&1; then
            echo "::error::Failed to clone wiki repository"
            echo "::error::Ensure the wiki has been initialized with at least one page"
            exit 1
          fi

          echo "âœ… Successfully cloned wiki repository"

          # Detect wiki branch
          cd wiki
          WIKI_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          echo "wiki_branch=$WIKI_BRANCH" >> "$GITHUB_OUTPUT"
          echo "Wiki branch: $WIKI_BRANCH"

      - name: Prepare wiki content
        id: prepare
        run: |
          set -euo pipefail

          # Track statistics
          pages_created=0
          images_copied=0

          # Clear existing wiki content (except .git and special wiki files we'll regenerate)
          echo "Clearing existing wiki content..."
          find wiki -mindepth 1 -maxdepth 1 ! -name '.git' -exec rm -rf {} +

          # Copy README as Home page
          echo "Creating Home.md from README.md..."
          cp main/README.md wiki/Home.md
          pages_created=$((pages_created + 1))

          # Copy CHANGELOG
          echo "Creating CHANGELOG.md..."
          cp main/CHANGELOG.md wiki/CHANGELOG.md
          pages_created=$((pages_created + 1))

          # Copy index.md if it exists and differs from README
          if [ -f "main/index.md" ]; then
            echo "Creating Index.md..."
            cp main/index.md wiki/Index.md
            pages_created=$((pages_created + 1))
          fi

          # Process and copy docs with proper structure
          echo "Processing documentation files..."
          cd main/docs

          # Create wiki pages from docs structure - use process substitution to avoid subshell
          # Note: Not using -print0/-d '' because wiki forbids filenames with spaces
          while IFS= read -r file; do
            # Remove leading ./
            file="${file#./}"

            # Create wiki-friendly filename:
            # 1. Replace / with -
            # 2. Capitalize first letter of each segment
            wiki_name=$(echo "$file" | sed 's|/|-|g' | sed 's|\.md$||')

            # Capitalize each segment after dash
            wiki_name=$(echo "$wiki_name" | awk -F'-' '{for(i=1;i<=NF;i++){$i=toupper(substr($i,1,1))substr($i,2)}}1' OFS='-')
            wiki_name="${wiki_name}.md"

            # Copy file
            cp "$file" "../../wiki/$wiki_name"
            echo "  ðŸ“„ Created: $wiki_name (from $file)"
            pages_created=$((pages_created + 1))
          done < <(find . -name "*.md" -type f ! -name "*.meta" | sort)

          # Copy images - handle nested image directories
          echo "Copying images..."
          if [ -d "images" ]; then
            while IFS= read -r img; do
              mkdir -p "../../wiki/$(dirname "$img")"
              cp "$img" "../../wiki/$img"
              echo "  ðŸ–¼ï¸  Copied: $img"
              images_copied=$((images_copied + 1))
            done < <(find images -type f ! -name "*.meta" 2>/dev/null || true)
          fi

          cd ../..

          echo "pages_created=$pages_created" >> "$GITHUB_OUTPUT"
          echo "images_copied=$images_copied" >> "$GITHUB_OUTPUT"
          echo ""
          echo "âœ… Content preparation complete"
          echo "   Pages: $pages_created"
          echo "   Images: $images_copied"

      - name: Fix wiki links
        run: |
          set -euo pipefail
          cd wiki

          echo "Fixing wiki links..."
          links_fixed=0

          for file in *.md; do
            if [ -f "$file" ]; then
              original_hash=$(md5sum "$file" | cut -d' ' -f1)

              # Fix relative doc links - convert paths to wiki page references
              # Handle ../path/to/file.md and ./path/to/file.md patterns
              sed -i -E 's|\(\.\.?/([^)]+)\.md\)|(\1)|g' "$file"

              # Convert path separators to dashes and capitalize for wiki links
              # This handles links like (features/inspector/overview) â†’ (Features-Inspector-Overview)
              sed -i -E 's|\(([a-z][^)]*)/([^)]*)\)|(\u\1-\u\2)|g' "$file"

              # Fix image paths - normalize to images/ prefix
              sed -i 's|docs/images/|images/|g' "$file"
              sed -i 's|\.\./images/|images/|g' "$file"
              sed -i 's|\./images/|images/|g' "$file"

              # Check if file was modified
              new_hash=$(md5sum "$file" | cut -d' ' -f1)
              if [ "$original_hash" != "$new_hash" ]; then
                echo "  ðŸ”— Fixed links in: $file"
                links_fixed=$((links_fixed + 1))
              fi
            fi
          done

          echo "âœ… Link fixing complete ($links_fixed files updated)"

      - name: Generate sidebar
        run: |
          set -euo pipefail
          cd wiki

          echo "Generating _Sidebar.md dynamically from actual files..."

          # Function to convert wiki filename to display name
          # e.g., "Features-Inspector-Inspector-Overview" -> "Inspector Overview"
          # e.g., "Features-Inspector-Utility-Components" -> "Utility Components"
          # e.g., "Overview-Getting-Started" -> "Getting Started"
          get_display_name() {
            local wiki_name="$1"
            local display="$wiki_name"

            # Remove top-level category prefix (Features, Overview, Performance, Guides, Project)
            # Using sed for extended regex alternation which can't be done with bash substitution
            # shellcheck disable=SC2001
            display=$(echo "$display" | sed -E 's/^(Features|Overview|Performance|Guides|Project)-//')

            # Remove subcategory prefix only if it matches known subcategories
            # This preserves context for files like "Utilities-Data-Structures" -> "Data Structures"
            # shellcheck disable=SC2001
            display=$(echo "$display" | sed -E 's/^(Inspector|Effects|Relational-Components|Serialization|Spatial|Logging|Utilities|Editor-Tools)-//')

            # Convert remaining dashes to spaces
            display="${display//-/ }"
            echo "$display"
          }

          # Start building the sidebar
          {
            echo "## ðŸ“š Documentation"
            echo ""
            echo "### Getting Started"
            echo "- [[Home]]"

            # Overview section
            for file in Overview-*.md; do
              [ -f "$file" ] || continue
              wiki_name="${file%.md}"
              display=$(get_display_name "$wiki_name")
              echo "- [[$wiki_name|$display]]"
            done

            echo ""
            echo "### Inspector Features"
            for file in Features-Inspector-*.md; do
              [ -f "$file" ] || continue
              wiki_name="${file%.md}"
              display=$(get_display_name "$wiki_name")
              echo "- [[$wiki_name|$display]]"
            done

            echo ""
            echo "### Effects System"
            for file in Features-Effects-*.md; do
              [ -f "$file" ] || continue
              wiki_name="${file%.md}"
              display=$(get_display_name "$wiki_name")
              echo "- [[$wiki_name|$display]]"
            done

            echo ""
            echo "### Relational Components"
            for file in Features-Relational-Components-*.md; do
              [ -f "$file" ] || continue
              wiki_name="${file%.md}"
              display=$(get_display_name "$wiki_name")
              echo "- [[$wiki_name|$display]]"
            done

            echo ""
            echo "### Serialization"
            for file in Features-Serialization-*.md; do
              [ -f "$file" ] || continue
              wiki_name="${file%.md}"
              display=$(get_display_name "$wiki_name")
              echo "- [[$wiki_name|$display]]"
            done

            echo ""
            echo "### Spatial Trees"
            for file in Features-Spatial-*.md; do
              [ -f "$file" ] || continue
              wiki_name="${file%.md}"
              display=$(get_display_name "$wiki_name")
              echo "- [[$wiki_name|$display]]"
            done

            echo ""
            echo "### Logging"
            for file in Features-Logging-*.md; do
              [ -f "$file" ] || continue
              wiki_name="${file%.md}"
              display=$(get_display_name "$wiki_name")
              echo "- [[$wiki_name|$display]]"
            done

            echo ""
            echo "### Utilities"
            for file in Features-Utilities-*.md; do
              [ -f "$file" ] || continue
              wiki_name="${file%.md}"
              display=$(get_display_name "$wiki_name")
              echo "- [[$wiki_name|$display]]"
            done

            echo ""
            echo "### Editor Tools"
            for file in Features-Editor-Tools-*.md; do
              [ -f "$file" ] || continue
              wiki_name="${file%.md}"
              display=$(get_display_name "$wiki_name")
              echo "- [[$wiki_name|$display]]"
            done

            echo ""
            echo "### Guides"
            for file in Guides-*.md; do
              [ -f "$file" ] || continue
              wiki_name="${file%.md}"
              display=$(get_display_name "$wiki_name")
              echo "- [[$wiki_name|$display]]"
            done

            echo ""
            echo "### Performance"
            for file in Performance-*.md; do
              [ -f "$file" ] || continue
              wiki_name="${file%.md}"
              display=$(get_display_name "$wiki_name")
              echo "- [[$wiki_name|$display]]"
            done

            echo ""
            echo "### Project"
            echo "- [[CHANGELOG|Changelog]]"
            for file in Project-*.md; do
              [ -f "$file" ] || continue
              wiki_name="${file%.md}"
              display=$(get_display_name "$wiki_name")
              echo "- [[$wiki_name|$display]]"
            done
          } > _Sidebar.md

          echo "Generated sidebar content:"
          cat _Sidebar.md
          echo ""
          echo "âœ… Sidebar generated dynamically"

      - name: Generate footer
        run: |
          set -euo pipefail
          cd wiki

          echo "Generating _Footer.md..."

          cat > _Footer.md << 'FOOTER_EOF'
          ---
          ðŸ“¦ [Unity Helpers](https://github.com/wallstop/unity-helpers) |
          ðŸ“– [Documentation](https://wallstop.github.io/unity-helpers/) |
          ðŸ› [Issues](https://github.com/wallstop/unity-helpers/issues) |
          ðŸ“œ [MIT License](https://github.com/wallstop/unity-helpers/blob/main/LICENSE)
          FOOTER_EOF

          echo "âœ… Footer generated"

      - name: Validate wiki content
        run: |
          set -euo pipefail
          cd wiki

          echo "Validating wiki content..."
          errors=0
          warnings=0

          # Check for required pages
          required_pages=("Home.md" "CHANGELOG.md" "_Sidebar.md" "_Footer.md")
          for page in "${required_pages[@]}"; do
            if [ ! -f "$page" ]; then
              echo "::error::Required page missing: $page"
              errors=$((errors + 1))
            fi
          done

          # Check for empty files
          while IFS= read -r -d '' file; do
            if [ ! -s "$file" ]; then
              echo "::warning::Empty file detected: $file"
              warnings=$((warnings + 1))
            fi
          done < <(find . -name "*.md" -print0)

          # Validate sidebar links - ensure all [[PageName]] references have corresponding files
          echo ""
          echo "Validating sidebar links..."
          if [ -f "_Sidebar.md" ]; then
            # Extract all [[PageName|...]] patterns and check each exists
            # Using command substitution to capture missing page names from a subshell loop
            missing_pages=$(grep -oE '\[\[[A-Za-z0-9-]+' _Sidebar.md | sed 's/\[\[//' | sort -u | while read -r page; do
              [ ! -f "$page.md" ] && echo "$page"
            done || true)
            if [ -n "$missing_pages" ]; then
              echo "Missing pages referenced in sidebar:"
              echo "$missing_pages"
              # Count missing pages and add to errors
              missing_count=$(echo "$missing_pages" | grep -c . || echo "0")
              errors=$((errors + missing_count))
            fi
          fi

          # Count total pages
          total_pages=$(find . -name "*.md" -type f | wc -l)
          total_images=$(find . -type f ! -name "*.md" ! -path "./.git/*" | wc -l)

          echo ""
          echo "ðŸ“Š Wiki Statistics:"
          echo "   Total pages: $total_pages"
          echo "   Total images: $total_images"
          echo "   Errors: $errors"
          echo "   Warnings: $warnings"

          # List all generated wiki pages for debugging
          echo ""
          echo "ðŸ“„ Generated wiki pages:"
          find . -name "*.md" -type f | sort | sed 's|^\./||'

          if [ "$errors" -gt 0 ]; then
            echo "::error::Validation failed with $errors errors"
            exit 1
          fi

          echo "âœ… Validation passed"

      - name: Check for changes
        id: changes
        run: |
          set -euo pipefail
          cd wiki

          git add -A

          if git diff --staged --quiet; then
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            echo "ðŸ“‹ No changes detected in wiki content"
          else
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
            echo "ðŸ“‹ Changes detected:"
            git diff --staged --stat
          fi

      - name: Commit and push to wiki
        if: steps.changes.outputs.has_changes == 'true' || github.event.inputs.force_sync == 'true'
        run: |
          set -euo pipefail
          cd wiki

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Prepare commit message with metadata
          COMMIT_MSG="Sync documentation from main repository

          Source commit: ${{ github.sha }}
          Triggered by: ${{ github.event_name }}
          Workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # Stage all changes
          git add -A

          # Check for changes again (in case force_sync but no actual changes)
          if git diff --staged --quiet; then
            echo "::notice::No changes to commit (force_sync enabled but content identical)"
            exit 0
          fi

          # Dry run mode
          if [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "ðŸ” DRY RUN MODE - Changes that would be committed:"
            git diff --staged --stat
            echo ""
            echo "Commit message would be:"
            echo "$COMMIT_MSG"
            exit 0
          fi

          # Commit changes
          git commit -m "$COMMIT_MSG"

          # Push to wiki (try detected branch first, then common alternatives)
          WIKI_BRANCH="${{ steps.clone-wiki.outputs.wiki_branch }}"
          echo "Pushing to wiki branch: $WIKI_BRANCH"

          if ! git push origin "$WIKI_BRANCH"; then
            echo "::warning::Push to $WIKI_BRANCH failed, trying alternatives..."
            if ! git push origin master 2>/dev/null; then
              if ! git push origin main 2>/dev/null; then
                echo "::error::Failed to push to wiki repository"
                exit 1
              fi
            fi
          fi

          echo ""
          echo "âœ… Successfully synced documentation to wiki"
          echo "ðŸ”— View wiki: https://github.com/${{ github.repository }}/wiki"

      - name: Summary
        if: always()
        run: |
          {
            echo "## Wiki Sync Summary"
            echo ""

            if [ "${{ needs.check-wiki.outputs.wiki_exists }}" = "false" ]; then
              echo "âš ï¸ **Wiki not available** - Please enable and initialize the wiki first."
            elif [ "${{ steps.changes.outputs.has_changes }}" = "false" ] && [ "${{ github.event.inputs.force_sync }}" != "true" ]; then
              echo "âœ… **No changes detected** - Wiki is already up to date."
            elif [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
              echo "ðŸ” **Dry run completed** - No changes were pushed."
            else
              echo "âœ… **Wiki synced successfully**"
            fi

            echo ""
            echo "| Metric | Value |"
            echo "|--------|-------|"
            echo "| Trigger | \`${{ github.event_name }}\` |"
            echo "| Source Commit | \`${{ github.sha }}\` |"
            echo "| Wiki URL | [View Wiki](https://github.com/${{ github.repository }}/wiki) |"
          } >> "$GITHUB_STEP_SUMMARY"

  # Notify on failure
  notify-failure:
    name: Notify on failure
    needs: [check-wiki, sync-wiki]
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Create failure summary
        run: |
          {
            echo "## âŒ Wiki Sync Failed"
            echo ""
            echo "The wiki synchronization workflow failed."
            echo ""
            echo "### Troubleshooting Steps"
            echo ""
            echo "1. **Check if wiki is enabled**: Go to Settings â†’ Features â†’ Wikis"
            echo "2. **Initialize wiki**: Create at least one page manually in the wiki"
            echo "3. **Check permissions**: Ensure GITHUB_TOKEN has write access"
            echo "4. **Review logs**: Check the workflow logs for specific errors"
            echo ""
            echo "[View Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})"
          } >> "$GITHUB_STEP_SUMMARY"
