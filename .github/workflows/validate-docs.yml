name: Validate Documentation

on:
  push:
    branches:
      - main
    paths:
      - "docs/**"
      - "*.md"
      - "_config.yml"
      - "assets/**"
  pull_request:
    paths:
      - "docs/**"
      - "*.md"
      - "_config.yml"
      - "assets/**"
  workflow_dispatch:

jobs:
  validate-links:
    name: Validate Internal Links
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check internal markdown links exist
        run: |
          #!/bin/bash
          set -euo pipefail

          echo "ðŸ” Validating that internal markdown links point to existing files..."

          errors=0

          # URL-decode function (handles %XX encoding like %20 for spaces)
          urldecode() {
            local url_encoded="${1//+/ }"
            printf '%b' "${url_encoded//%/\\x}"
          }

          # Remove inline code spans (content between backticks) from a line
          # This prevents example links in inline code from being parsed
          strip_inline_code() {
            local line
            line="$1"
            # Remove content between backticks (handles single and double backticks)
            # Using sed to handle multiple inline code spans per line
            # shellcheck disable=SC2016
            echo "$line" | sed -E 's/``[^`]*``//g; s/`[^`]*`//g'
          }

          # Find all markdown files
          while IFS= read -r -d '' mdfile; do
            dir=$(dirname "$mdfile")
            in_code_block=false

            # Process file line by line to track code blocks
            while IFS= read -r line || [[ -n "$line" ]]; do
              # Check for code fence start/end (``` or ~~~)
              # Store fence pattern in variable to avoid shellcheck regex parse issues
              fence_pattern='^[[:space:]]*(```|~~~)'
              if [[ "$line" =~ $fence_pattern ]]; then
                if [[ "$in_code_block" == "true" ]]; then
                  in_code_block=false
                else
                  in_code_block=true
                fi
                continue
              fi

              # Skip lines inside code blocks
              if [[ "$in_code_block" == "true" ]]; then
                continue
              fi

              # Strip inline code before extracting links (example links in backticks)
              stripped_line=$(strip_inline_code "$line")

              # Extract markdown links from this line: [text](link)
              # Uses grep -oE (POSIX extended regex) + sed instead of grep -oP (GNU Perl regex)
              # grep -oP is unavailable on macOS and non-GNU systems
              while read -r link; do
                # Skip empty lines from grep/sed output
                [[ -z "$link" ]] && continue

                # Skip external links, anchors, and mailto
                if [[ "$link" =~ ^https?:// ]] || [[ "$link" =~ ^# ]] || [[ "$link" =~ ^mailto: ]]; then
                  continue
                fi

                # Remove anchor from link if present
                link_without_anchor="${link%%#*}"

                # Skip if empty (was just an anchor)
                if [[ -z "$link_without_anchor" ]]; then
                  continue
                fi

                # URL-decode the path (handles %20 for spaces, etc.)
                decoded_path=$(urldecode "$link_without_anchor")

                # Resolve the link path relative to the markdown file's directory
                if [[ "$decoded_path" == /* ]]; then
                  # Absolute path from repo root
                  target_path=".${decoded_path}"
                else
                  # Relative path
                  target_path="$dir/$decoded_path"
                fi

                # Normalize the path
                target_path=$(realpath -m "$target_path" 2>/dev/null || echo "$target_path")

                # Check if target exists
                if [[ ! -e "$target_path" ]]; then
                  echo "âŒ Broken link in $mdfile: $link -> $target_path (file not found)"
                  errors=$((errors + 1))
                fi
              done < <(echo "$stripped_line" | grep -oE '\]\([^)]+\)' 2>/dev/null | sed 's/^](//;s/)$//' || true)
            done < "$mdfile"
          done < <(find . -name "*.md" -type f -not -path "./node_modules/*" -print0)

          if [[ $errors -gt 0 ]]; then
            echo ""
            echo "âŒ Found $errors broken internal link(s)"
            exit 1
          fi

          echo "âœ… All internal links are valid"

  validate-link-format:
    name: Validate Link Format
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check markdown link format
        run: |
          #!/bin/bash
          set -euo pipefail

          echo "ðŸ” Checking that internal markdown links use proper relative format (./ or ../)..."

          # Find links that don't start with ./, ../, http, https, #, or mailto
          # These are internal links that should have a relative prefix
          # IMPORTANT: Skip content inside code blocks (```) and inline code (backticks)

          # Remove inline code spans (content between backticks) from a line
          strip_inline_code() {
            local line
            line="$1"
            # shellcheck disable=SC2016
            echo "$line" | sed -E 's/``[^`]*``//g; s/`[^`]*`//g'
          }

          violations=""

          while IFS= read -r -d '' mdfile; do
            in_code_block=false
            line_num=0

            while IFS= read -r line || [[ -n "$line" ]]; do
              line_num=$((line_num + 1))

              # Check for code fence start/end (``` or ~~~)
              # Store fence pattern in variable to avoid shellcheck regex parse issues
              fence_pattern='^[[:space:]]*(```|~~~)'
              if [[ "$line" =~ $fence_pattern ]]; then
                if [[ "$in_code_block" == "true" ]]; then
                  in_code_block=false
                else
                  in_code_block=true
                fi
                continue
              fi

              # Skip lines inside code blocks
              if [[ "$in_code_block" == "true" ]]; then
                continue
              fi

              # Strip inline code before checking links (example links in backticks)
              stripped_line=$(strip_inline_code "$line")

              # Check for links missing relative prefix (./ or ../)
              # Match ](something) where something starts with a letter (not ./ ../ http # mailto)
              if echo "$stripped_line" | grep -qE '\]\([a-zA-Z]' && \
                 ! echo "$stripped_line" | grep -qE '\]\(\.\./|\]\(\./|\]\(https?://|\]\(#|\]\(mailto:'; then
                violations="${violations}${mdfile}:${line_num}:${line}"$'\n'
              fi
            done < "$mdfile"
          done < <(find . -name "*.md" -type f -not -path "./node_modules/*" -print0)

          if [[ -n "$violations" ]]; then
            echo "âŒ Found markdown links missing relative prefix (./ or ../):"
            echo ""
            echo "$violations"
            echo ""
            echo "Links to local files should use relative paths like:"
            echo "  - Use ./file format instead of bare file"
            echo "  - Use ./docs/file format instead of docs/file"
            echo ""
            exit 1
          fi

          echo "âœ… All internal links use proper relative format"

  build-jekyll-test:
    name: Build Jekyll Site
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: true

      - name: Install dependencies
        run: |
          if [[ -f Gemfile ]]; then
            bundle install
          else
            gem install jekyll bundler
          fi

      - name: Build Jekyll site
        run: |
          if [[ -f Gemfile ]]; then
            bundle exec jekyll build --strict_front_matter
          else
            jekyll build --strict_front_matter
          fi
        env:
          JEKYLL_ENV: production

      - name: Verify build output
        run: |
          if [[ -d "_site" ]]; then
            echo "âœ… Jekyll site built successfully"
            echo "ðŸ“ Site contents:"
            find _site -type f | head -20
          else
            echo "âŒ Jekyll build did not produce _site directory"
            exit 1
          fi
