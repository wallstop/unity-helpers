#!/usr/bin/env bash
set -e

# Source git staging helpers for safe index.lock handling
# This prevents "fatal: Unable to create '.git/index.lock': File exists" errors
# when using interactive git tools like lazygit that may hold locks
SCRIPT_DIR="$(cd "$(dirname "$0")/.." && pwd)"
HELPERS_PATH="$SCRIPT_DIR/scripts/git-staging-helpers.sh"
if [[ -f "$HELPERS_PATH" ]]; then
    # shellcheck source=../scripts/git-staging-helpers.sh
    source "$HELPERS_PATH"
else
    echo "Warning: git-staging-helpers.sh not found at $HELPERS_PATH" >&2
    echo "Falling back to basic git add (may cause index.lock errors)" >&2
    # Fallback: define basic versions of the functions
    git_add_with_retry() {
        git add -- "$@"
    }
    ensure_no_index_lock() {
        return 0  # No-op fallback
    }
fi

# CRITICAL: Wait for any external tool (lazygit, IDE, etc.) to release the index.lock
# before starting hook operations. This is the primary fix for index.lock contention.
# Without this, the hook may start while lazygit is still holding the lock.
ensure_no_index_lock || {
    echo "Warning: index.lock still held after waiting. Proceeding anyway, but operations may fail." >&2
}

# 0) Sync banner version from package.json (runs on every commit)
# This ensures the SVG banner always displays the correct version
if command -v pwsh >/dev/null 2>&1; then
  pwsh -NoProfile -File scripts/sync-banner-version.ps1
elif command -v powershell >/dev/null 2>&1; then
  powershell -NoProfile -ExecutionPolicy Bypass -File scripts/sync-banner-version.ps1
else
  echo "PowerShell not found. Skipping banner version sync." >&2
fi

# 1) Normalize line endings (LF -> CRLF for most files, LF for .sh)
# This MUST run before any other formatting to prevent formatter diffs
if command -v pwsh >/dev/null 2>&1; then
  pwsh -NoProfile -File scripts/normalize-eol.ps1
elif command -v powershell >/dev/null 2>&1; then
  powershell -NoProfile -ExecutionPolicy Bypass -File scripts/normalize-eol.ps1
else
  echo "PowerShell not found. Skipping EOL normalization." >&2
fi

# 2) Ensure .NET tools available (for CSharpier)
if command -v dotnet >/dev/null 2>&1; then
  dotnet tool restore >/dev/null 2>&1 || true
fi

# 3) Lint Markdown link text style (via Node wrapper -> PowerShell script)
if command -v node >/dev/null 2>&1; then
  node ./scripts/run-doc-link-lint.js
else
  run_pwsh() {
    pwsh -NoProfile -File scripts/lint-doc-links.ps1
  }

  run_windows_ps() {
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/lint-doc-links.ps1
  }

  if command -v pwsh >/dev/null 2>&1; then
    run_pwsh
  elif command -v powershell >/dev/null 2>&1; then
    run_windows_ps
  else
    echo "PowerShell not found. Please install Node.js (preferred) or pwsh/powershell to run docs linter." >&2
    exit 1
  fi
fi

# 4) Format staged Markdown/JSON/YAML with Prettier and re-stage
if ! command -v npx >/dev/null 2>&1; then
  echo "npx is required for formatting. Please install Node.js." >&2
  exit 1
fi

# ============================================================================
# SECURITY: Safe file list handling
# ============================================================================
# File lists are read using null-delimited (-z) output from git and stored in
# bash arrays. This prevents shell injection attacks via crafted filenames
# containing spaces, newlines, semicolons, or other special characters.
#
# Pattern: git diff -z | while IFS= read -r -d '' file; do array+=("$file"); done
# This ensures each filename is treated as a single atomic argument, regardless
# of what characters it contains.
# ============================================================================

# Read staged files into an array safely using null-delimited output
STAGED_FILES_ARRAY=()
while IFS= read -r -d '' file; do
    STAGED_FILES_ARRAY+=("$file")
done < <(git diff --cached --name-only --diff-filter=ACM -z)

# Filter files into type-specific arrays
MD_FILES_ARRAY=()
JSON_FILES_ARRAY=()
YAML_FILES_ARRAY=()
CS_FILES_ARRAY=()
SPELL_FILES_ARRAY=()

for file in "${STAGED_FILES_ARRAY[@]}"; do
    case "$file" in
        *.md|*.markdown)
            MD_FILES_ARRAY+=("$file")
            SPELL_FILES_ARRAY+=("$file")
            ;;
        *.json|*.asmdef|*.asmref)
            JSON_FILES_ARRAY+=("$file")
            SPELL_FILES_ARRAY+=("$file")
            ;;
        *.yml|*.yaml)
            YAML_FILES_ARRAY+=("$file")
            SPELL_FILES_ARRAY+=("$file")
            ;;
        *.cs)
            CS_FILES_ARRAY+=("$file")
            SPELL_FILES_ARRAY+=("$file")
            ;;
    esac
done

# ============================================================================
# LINE ENDING CONFIGURATION
# ============================================================================
# Most files use CRLF (C#, JSON, Markdown) - see .gitattributes.
# 
# EXCEPTIONS that MUST use LF:
#   - YAML files (.yml, .yaml) - cross-platform compatibility
#   - Shell scripts (.sh) - Unix requirement
#   - .github/** ALL files - GitHub Actions run on Linux, Dependabot commits LF
#     This includes .github/*.md files (copilot-instructions.md, etc.)
#
# The normalize-eol.ps1 script (step 1) handles this automatically.
# Prettier uses .prettierrc.json overrides for LF files.
# If you see EOL-related CI failures, run: npm run fix:eol
# ============================================================================

# Prettier format and re-add using retry logic to handle index.lock contention
if [ ${#MD_FILES_ARRAY[@]} -gt 0 ]; then
  npx --no-install prettier --write --log-level warn "${MD_FILES_ARRAY[@]}"
  # Verify formatting was successful before re-staging
  if ! npx --no-install prettier --check "${MD_FILES_ARRAY[@]}" >/dev/null 2>&1; then
    echo "Error: Prettier formatting verification failed for Markdown files." >&2
    exit 1
  fi
  # Use git_add_with_retry to handle concurrent git operations safely
  git_add_with_retry "${MD_FILES_ARRAY[@]}"
fi

if [ ${#JSON_FILES_ARRAY[@]} -gt 0 ]; then
  npx --no-install prettier --write --log-level warn "${JSON_FILES_ARRAY[@]}"
  # Verify formatting was successful before re-staging
  if ! npx --no-install prettier --check "${JSON_FILES_ARRAY[@]}" >/dev/null 2>&1; then
    echo "Error: Prettier formatting verification failed for JSON files." >&2
    exit 1
  fi
  # Use git_add_with_retry to handle concurrent git operations safely
  git_add_with_retry "${JSON_FILES_ARRAY[@]}"
fi

if [ ${#YAML_FILES_ARRAY[@]} -gt 0 ]; then
  npx --no-install prettier --write --log-level warn "${YAML_FILES_ARRAY[@]}"
  # Verify formatting was successful before re-staging
  if ! npx --no-install prettier --check "${YAML_FILES_ARRAY[@]}" >/dev/null 2>&1; then
    echo "Error: Prettier formatting verification failed for YAML files." >&2
    exit 1
  fi
  # Use git_add_with_retry to handle concurrent git operations safely
  git_add_with_retry "${YAML_FILES_ARRAY[@]}"
fi

# 5) Format staged C# files with CSharpier (if available) and re-stage
if [ ${#CS_FILES_ARRAY[@]} -gt 0 ]; then
  if command -v pwsh >/dev/null 2>&1; then
    pwsh -NoProfile -File scripts/format-staged-csharp.ps1
  elif command -v powershell >/dev/null 2>&1; then
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/format-staged-csharp.ps1
  else
    echo "PowerShell not found. Skipping CSharpier formatting." >&2
  fi
fi

# 6) Markdown lint for staged Markdown files
if [ ${#MD_FILES_ARRAY[@]} -gt 0 ]; then
  # First, auto-fix what can be fixed
  npx --no-install markdownlint --fix "${MD_FILES_ARRAY[@]}" --config .markdownlint.json --ignore-path .markdownlintignore || true
  # Re-stage the fixed files
  git_add_with_retry "${MD_FILES_ARRAY[@]}"
  # Then run markdownlint again to catch any remaining unfixable issues
  npx --no-install markdownlint "${MD_FILES_ARRAY[@]}" --config .markdownlint.json --ignore-path .markdownlintignore
fi

# 7) YAML lint on staged YAML files
if [ ${#YAML_FILES_ARRAY[@]} -gt 0 ]; then
  if command -v yamllint >/dev/null 2>&1; then
    yamllint -c .yamllint.yaml "${YAML_FILES_ARRAY[@]}"
  else
    echo "yamllint not found; skipping YAML lint (run 'npm run verify:tools' to check setup)." >&2
  fi
fi

# 8) Spell check staged files with cspell
# Runs on markdown, code, and config files
if [ ${#SPELL_FILES_ARRAY[@]} -gt 0 ]; then
  if npx --no-install cspell --version >/dev/null 2>&1; then
    echo "Running spell check on staged files..."
    # Use a temp file to avoid Windows command length limits with large staged sets
    SPELL_FILE_LIST="$(mktemp 2>/dev/null || true)"
    if [ -z "$SPELL_FILE_LIST" ]; then
      echo "Error: Failed to create temporary file for spell check file list." >&2
      exit 1
    fi

    trap 'rm -f "$SPELL_FILE_LIST"' EXIT
    printf '%s\n' "${SPELL_FILES_ARRAY[@]}" > "$SPELL_FILE_LIST"
    # Use --no-must-find-files to avoid errors when files are filtered by cspell config
    npx --no-install cspell lint --no-must-find-files --no-progress --file-list "$SPELL_FILE_LIST" || {
      echo "Spell check failed. Fix spelling errors or add words to cspell.json." >&2
      exit 1
    }
  else
    echo "cspell not found; skipping spell check (run 'npm install' to install)." >&2
  fi
fi

# 9) Validate LLM instructions if .llm/ files are staged
LLM_FILES_ARRAY=()
for file in "${STAGED_FILES_ARRAY[@]}"; do
    case "$file" in
        .llm/*)
            LLM_FILES_ARRAY+=("$file")
            ;;
    esac
done

if [ ${#LLM_FILES_ARRAY[@]} -gt 0 ]; then
  echo "Validating LLM instructions..."
  if command -v pwsh >/dev/null 2>&1; then
    pwsh -NoProfile -File scripts/lint-llm-instructions.ps1 || {
      echo "LLM instructions validation failed. Run 'pwsh -NoProfile -File scripts/lint-llm-instructions.ps1 -Fix' to auto-fix." >&2
      exit 1
    }
  elif command -v powershell >/dev/null 2>&1; then
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/lint-llm-instructions.ps1 || {
      echo "LLM instructions validation failed. Run 'powershell -NoProfile -File scripts/lint-llm-instructions.ps1 -Fix' to auto-fix." >&2
      exit 1
    }
  else
    echo "PowerShell not found. Skipping LLM instructions validation." >&2
  fi
fi

# 10) Check skill file sizes if .llm/skills/*.md files are staged
LLM_SKILLS_ARRAY=()
for file in "${STAGED_FILES_ARRAY[@]}"; do
    case "$file" in
        .llm/skills/*.md)
            LLM_SKILLS_ARRAY+=("$file")
            ;;
    esac
done

if [ ${#LLM_SKILLS_ARRAY[@]} -gt 0 ]; then
  echo "Checking skill file sizes..."
  if command -v pwsh >/dev/null 2>&1; then
    pwsh -NoProfile -File scripts/lint-skill-sizes.ps1 || {
      echo "Skill file size check failed. Some files exceed 500 lines and must be split." >&2
      exit 1
    }
  elif command -v powershell >/dev/null 2>&1; then
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/lint-skill-sizes.ps1 || {
      echo "Skill file size check failed. Some files exceed 500 lines and must be split." >&2
      exit 1
    }
  else
    echo "PowerShell not found. Skipping skill file size check." >&2
  fi
fi

# 11) Run test linter on staged test files
# Checks for Unity object lifecycle issues (UNH001-UNH003) and naming conventions (UNH004)
TEST_FILES_ARRAY=()
for file in "${STAGED_FILES_ARRAY[@]}"; do
    case "$file" in
        Tests/*.cs)
            TEST_FILES_ARRAY+=("$file")
            ;;
    esac
done

if [ ${#TEST_FILES_ARRAY[@]} -gt 0 ]; then
  echo "Running test linter on staged test files..."
  if command -v pwsh >/dev/null 2>&1; then
    pwsh -NoProfile -File scripts/lint-tests.ps1 || {
      echo "" >&2
      echo "=== Test lint failed ===" >&2
      echo "Fix the issues above or add // UNH-SUPPRESS comments for valid exceptions." >&2
      echo "For naming convention errors (UNH004):" >&2
      echo "  - Use PascalCase or dot notation in TestName/SetName (e.g., 'Input.Null.ReturnsFalse')" >&2
      echo "  - Use PascalCase for TestCaseSource method names (e.g., 'EdgeCaseTestData')" >&2
      echo "" >&2
      exit 1
    }
  elif command -v powershell >/dev/null 2>&1; then
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/lint-tests.ps1 || {
      echo "" >&2
      echo "=== Test lint failed ===" >&2
      echo "Fix the issues above or add // UNH-SUPPRESS comments for valid exceptions." >&2
      echo "For naming convention errors (UNH004):" >&2
      echo "  - Use PascalCase or dot notation in TestName/SetName (e.g., 'Input.Null.ReturnsFalse')" >&2
      echo "  - Use PascalCase for TestCaseSource method names (e.g., 'EdgeCaseTestData')" >&2
      echo "" >&2
      exit 1
    }
  else
    echo "PowerShell not found. Skipping test linter." >&2
  fi
fi
