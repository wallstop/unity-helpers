#!/usr/bin/env bash
set -e

# Source git staging helpers for safe index.lock handling
# This prevents "fatal: Unable to create '.git/index.lock': File exists" errors
# when using interactive git tools like lazygit that may hold locks
SCRIPT_DIR="$(cd "$(dirname "$0")/.." && pwd)"
HELPERS_PATH="$SCRIPT_DIR/scripts/git-staging-helpers.sh"
if [[ -f "$HELPERS_PATH" ]]; then
    # shellcheck source=../scripts/git-staging-helpers.sh
    source "$HELPERS_PATH"
else
    echo "Warning: git-staging-helpers.sh not found at $HELPERS_PATH" >&2
    echo "Falling back to basic git add (may cause index.lock errors)" >&2
    # Fallback: define basic versions of the functions
    git_add_with_retry() {
        git add -- "$@"
    }
    ensure_no_index_lock() {
        return 0  # No-op fallback
    }
fi

# CRITICAL: Wait for any external tool (lazygit, IDE, etc.) to release the index.lock
# before starting hook operations. This is the primary fix for index.lock contention.
# Without this, the hook may start while lazygit is still holding the lock.
ensure_no_index_lock || {
    echo "Warning: index.lock still held after waiting. Proceeding anyway, but operations may fail." >&2
}

# 0) Sync banner version from package.json (runs on every commit)
# This ensures the SVG banner always displays the correct version
if command -v pwsh >/dev/null 2>&1; then
  pwsh -NoProfile -File scripts/sync-banner-version.ps1
elif command -v powershell >/dev/null 2>&1; then
  powershell -NoProfile -ExecutionPolicy Bypass -File scripts/sync-banner-version.ps1
else
  echo "PowerShell not found. Skipping banner version sync." >&2
fi

# 1) Normalize line endings (LF -> CRLF for most files, LF for .sh)
# This MUST run before any other formatting to prevent formatter diffs
if command -v pwsh >/dev/null 2>&1; then
  pwsh -NoProfile -File scripts/normalize-eol.ps1
elif command -v powershell >/dev/null 2>&1; then
  powershell -NoProfile -ExecutionPolicy Bypass -File scripts/normalize-eol.ps1
else
  echo "PowerShell not found. Skipping EOL normalization." >&2
fi

# 2) Ensure .NET tools available (for CSharpier)
if command -v dotnet >/dev/null 2>&1; then
  dotnet tool restore >/dev/null 2>&1 || true
fi

# 3) Lint Markdown link text style (via Node wrapper -> PowerShell script)
if command -v node >/dev/null 2>&1; then
  node ./scripts/run-doc-link-lint.js
else
  run_pwsh() {
    pwsh -NoProfile -File scripts/lint-doc-links.ps1
  }

  run_windows_ps() {
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/lint-doc-links.ps1
  }

  if command -v pwsh >/dev/null 2>&1; then
    run_pwsh
  elif command -v powershell >/dev/null 2>&1; then
    run_windows_ps
  else
    echo "PowerShell not found. Please install Node.js (preferred) or pwsh/powershell to run docs linter." >&2
    exit 1
  fi
fi

# 4) Format staged Markdown/JSON/YAML with Prettier and re-stage
if ! command -v npx >/dev/null 2>&1; then
  echo "npx is required for formatting. Please install Node.js." >&2
  exit 1
fi

STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

# Collect file lists
MD_FILES=$(echo "$STAGED_FILES" | grep -E '\\.(md|markdown)$' || true)
JSON_FILES=$(echo "$STAGED_FILES" | grep -E '\\.(json|asmdef|asmref)$' || true)
YAML_FILES=$(echo "$STAGED_FILES" | grep -E '\\.(yml|yaml)$' || true)

# ============================================================================
# LINE ENDING CONFIGURATION
# ============================================================================
# Most files use CRLF (C#, JSON, Markdown) - see .gitattributes.
# YAML files (.yml, .yaml) and shell scripts (.sh) use LF for compatibility.
# The normalize-eol.ps1 script (step 1) converts LF -> CRLF for text files.
# If you see EOL-related CI failures, run: npm run fix:eol
# ============================================================================

# Prettier format and re-add using retry logic to handle index.lock contention
if [ -n "$MD_FILES" ]; then
  echo "$MD_FILES" | xargs npx --no-install prettier --write --log-level warn
  # Verify formatting was successful before re-staging
  # shellcheck disable=SC2086
  if ! echo "$MD_FILES" | xargs npx --no-install prettier --check >/dev/null 2>&1; then
    echo "Error: Prettier formatting verification failed for Markdown files." >&2
    exit 1
  fi
  # Use git_add_with_retry to handle concurrent git operations safely
  # shellcheck disable=SC2086
  git_add_with_retry $MD_FILES
fi

if [ -n "$JSON_FILES" ]; then
  echo "$JSON_FILES" | xargs npx --no-install prettier --write --log-level warn
  # Verify formatting was successful before re-staging
  # shellcheck disable=SC2086
  if ! echo "$JSON_FILES" | xargs npx --no-install prettier --check >/dev/null 2>&1; then
    echo "Error: Prettier formatting verification failed for JSON files." >&2
    exit 1
  fi
  # Use git_add_with_retry to handle concurrent git operations safely
  # shellcheck disable=SC2086
  git_add_with_retry $JSON_FILES
fi

if [ -n "$YAML_FILES" ]; then
  echo "$YAML_FILES" | xargs npx --no-install prettier --write --log-level warn
  # Verify formatting was successful before re-staging
  # shellcheck disable=SC2086
  if ! echo "$YAML_FILES" | xargs npx --no-install prettier --check >/dev/null 2>&1; then
    echo "Error: Prettier formatting verification failed for YAML files." >&2
    exit 1
  fi
  # Use git_add_with_retry to handle concurrent git operations safely
  # shellcheck disable=SC2086
  git_add_with_retry $YAML_FILES
fi

# 5) Format staged C# files with CSharpier (if available) and re-stage
CS_FILES=$(echo "$STAGED_FILES" | grep -E '\\\.cs$' || true)
if [ -n "$CS_FILES" ]; then
  if command -v pwsh >/dev/null 2>&1; then
    pwsh -NoProfile -File scripts/format-staged-csharp.ps1
  elif command -v powershell >/dev/null 2>&1; then
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/format-staged-csharp.ps1
  else
    echo "PowerShell not found. Skipping CSharpier formatting." >&2
  fi
fi

# 6) Markdown lint for staged Markdown files
if [ -n "$MD_FILES" ]; then
  npx --no-install markdownlint $MD_FILES --config .markdownlint.json --ignore-path .markdownlintignore
fi

# 7) YAML lint on staged YAML files
if [ -n "$YAML_FILES" ]; then
  if command -v yamllint >/dev/null 2>&1; then
    echo "$YAML_FILES" | xargs yamllint -c .yamllint.yaml
  else
    echo "yamllint not found; skipping YAML lint (run 'npm run verify:tools' to check setup)." >&2
  fi
fi

# 8) Spell check staged files with cspell
# Runs on markdown, code, and config files
SPELL_FILES=$(echo "$STAGED_FILES" | grep -E '\.(md|cs|json|yaml|yml)$' || true)
if [ -n "$SPELL_FILES" ]; then
  if npx --no-install cspell --version >/dev/null 2>&1; then
    echo "Running spell check on staged files..."
    # Use --no-must-find-files to avoid errors when files are filtered by cspell config
    # shellcheck disable=SC2086
    npx --no-install cspell lint --no-must-find-files --no-progress $SPELL_FILES || {
      echo "Spell check failed. Fix spelling errors or add words to cspell.json." >&2
      exit 1
    }
  else
    echo "cspell not found; skipping spell check (run 'npm install' to install)." >&2
  fi
fi

