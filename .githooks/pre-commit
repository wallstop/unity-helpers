#!/usr/bin/env bash
set -e

# Source git staging helpers for safe index.lock handling
# This prevents "fatal: Unable to create '.git/index.lock': File exists" errors
# when using interactive git tools like lazygit that may hold locks
SCRIPT_DIR="$(cd "$(dirname "$0")/.." && pwd)"
HELPERS_PATH="$SCRIPT_DIR/scripts/git-staging-helpers.sh"
if [[ -f "$HELPERS_PATH" ]]; then
    # shellcheck source=../scripts/git-staging-helpers.sh
    source "$HELPERS_PATH"
else
    echo "Warning: git-staging-helpers.sh not found at $HELPERS_PATH" >&2
    echo "Falling back to basic git add (may cause index.lock errors)" >&2
    # Fallback: define basic versions of the functions
    git_add_with_retry() {
        git add -- "$@"
    }
    ensure_no_index_lock() {
        return 0  # No-op fallback
    }
fi

# CRITICAL: Wait for any external tool (lazygit, IDE, etc.) to release the index.lock
# before starting hook operations. This is the primary fix for index.lock contention.
# Without this, the hook may start while lazygit is still holding the lock.
ensure_no_index_lock || {
    echo "Warning: index.lock still held after waiting. Proceeding anyway, but operations may fail." >&2
}

# 0) Sync version references (runs on every commit)
#    a) Syncs banner version and .llm/context.md from package.json
#    b) Syncs issue template package versions from package.json, CHANGELOG.md, and git tags
if command -v pwsh >/dev/null 2>&1; then
  pwsh -NoProfile -File scripts/sync-banner-version.ps1
  pwsh -NoProfile -File scripts/sync-issue-template-versions.ps1
elif command -v powershell >/dev/null 2>&1; then
  powershell -NoProfile -ExecutionPolicy Bypass -File scripts/sync-banner-version.ps1
  powershell -NoProfile -ExecutionPolicy Bypass -File scripts/sync-issue-template-versions.ps1
else
  echo "PowerShell not found. Skipping version sync." >&2
fi

# 1) Normalize line endings (LF -> CRLF for most files, LF for .sh)
# This MUST run before any other formatting to prevent formatter diffs
if command -v pwsh >/dev/null 2>&1; then
  pwsh -NoProfile -File scripts/normalize-eol.ps1
elif command -v powershell >/dev/null 2>&1; then
  powershell -NoProfile -ExecutionPolicy Bypass -File scripts/normalize-eol.ps1
else
  echo "PowerShell not found. Skipping EOL normalization." >&2
fi

# 2) Ensure .NET tools available (for CSharpier)
if command -v dotnet >/dev/null 2>&1; then
  dotnet tool restore >/dev/null 2>&1 || true
fi

# 3) Lint Markdown link text style (via Node wrapper -> PowerShell script)
if command -v node >/dev/null 2>&1; then
  node ./scripts/run-doc-link-lint.js
else
  run_pwsh() {
    pwsh -NoProfile -File scripts/lint-doc-links.ps1
  }

  run_windows_ps() {
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/lint-doc-links.ps1
  }

  if command -v pwsh >/dev/null 2>&1; then
    run_pwsh
  elif command -v powershell >/dev/null 2>&1; then
    run_windows_ps
  else
    echo "PowerShell not found. Please install Node.js (preferred) or pwsh/powershell to run docs linter." >&2
    exit 1
  fi
fi

# 4) Format staged Markdown/JSON/YAML with Prettier and re-stage
if ! command -v npx >/dev/null 2>&1; then
  echo "npx is required for formatting. Please install Node.js." >&2
  exit 1
fi

# ============================================================================
# SECURITY: Safe file list handling
# ============================================================================
# File lists are read using null-delimited (-z) output from git and stored in
# bash arrays. This prevents shell injection attacks via crafted filenames
# containing spaces, newlines, semicolons, or other special characters.
#
# Pattern: git diff -z | while IFS= read -r -d '' file; do array+=("$file"); done
# This ensures each filename is treated as a single atomic argument, regardless
# of what characters it contains.
# ============================================================================

# Read staged files into an array safely using null-delimited output
STAGED_FILES_ARRAY=()
while IFS= read -r -d '' file; do
    STAGED_FILES_ARRAY+=("$file")
done < <(git diff --cached --name-only --diff-filter=ACM -z)

# Early exit if no staged files (e.g., amend with no changes, or merge commit)
if [ ${#STAGED_FILES_ARRAY[@]} -eq 0 ]; then
    echo "No staged files to check. Skipping pre-commit hooks."
    exit 0
fi

# 5) Ensure staged text files end with a final newline
# This MUST run before Prettier formatting to prevent missing-newline diffs

# ============================================================================
# CRLF Detection Helper
# ============================================================================
# Detects if a file uses CRLF (Windows) line endings by checking for carriage
# return characters (0x0d). This is used to preserve the correct line ending
# style when appending a final newline to files.
#
# Returns:
#   0 (true)  - File uses CRLF line endings
#   1 (false) - File uses LF line endings (or is empty)
# ============================================================================
file_uses_crlf() {
    local file="$1"
    # Check if file is non-empty and contains CR characters (part of CRLF)
    if [[ -s "$file" ]] && grep -q $'\r' "$file" 2>/dev/null; then
        return 0  # Uses CRLF
    fi
    return 1  # Uses LF
}

FINAL_NEWLINE_PATTERNS=('*.json' '*.jsonc' '*.asmdef' '*.asmref' '*.md' '*.markdown'
    '*.yml' '*.yaml' '*.js' '*.ts' '*.cs' '*.sh' '*.ps1' '*.txt' '*.html' '*.css' '*.xml')
NEWLINE_FIXED=()
for file in "${STAGED_FILES_ARRAY[@]}"; do
    # Check if file matches any of the text patterns
    matched=0
    for pat in "${FINAL_NEWLINE_PATTERNS[@]}"; do
        # shellcheck disable=SC2254
        case "$file" in
            ${pat}) matched=1; break ;;
        esac
    done
    if [[ $matched -eq 1 ]] && [[ -s "$file" ]] && [[ "$(tail -c 1 -- "$file" | wc -l)" -eq 0 ]]; then
        # Append the correct newline based on the file's line ending style
        # CRLF files get \r\n, LF files get \n to avoid mixed line endings
        if file_uses_crlf "$file"; then
            printf '\r\n' >> "$file"
        else
            printf '\n' >> "$file"
        fi
        NEWLINE_FIXED+=("$file")
    fi
done
if [[ ${#NEWLINE_FIXED[@]} -gt 0 ]]; then
    echo "Added final newline to ${#NEWLINE_FIXED[@]} file(s):"
    for f in "${NEWLINE_FIXED[@]}"; do
        echo "  $f"
    done
    git_add_with_retry "${NEWLINE_FIXED[@]}"
fi

# Filter files into type-specific arrays
MD_FILES_ARRAY=()
JSON_FILES_ARRAY=()
YAML_FILES_ARRAY=()
JS_FILES_ARRAY=()
CS_FILES_ARRAY=()
SPELL_FILES_ARRAY=()

for file in "${STAGED_FILES_ARRAY[@]}"; do
    case "$file" in
        *.md|*.markdown)
            MD_FILES_ARRAY+=("$file")
            SPELL_FILES_ARRAY+=("$file")
            ;;
        *.json|*.jsonc|*.asmdef|*.asmref)
            JSON_FILES_ARRAY+=("$file")
            SPELL_FILES_ARRAY+=("$file")
            ;;
        *.yml|*.yaml)
            YAML_FILES_ARRAY+=("$file")
            SPELL_FILES_ARRAY+=("$file")
            ;;
        *.js)
            JS_FILES_ARRAY+=("$file")
            SPELL_FILES_ARRAY+=("$file")
            ;;
        *.cs)
            CS_FILES_ARRAY+=("$file")
            SPELL_FILES_ARRAY+=("$file")
            ;;
    esac
done

# ============================================================================
# LINE ENDING CONFIGURATION
# ============================================================================
# Most files use CRLF (C#, JSON, Markdown) - see .gitattributes.
# 
# EXCEPTIONS that MUST use LF:
#   - YAML files (.yml, .yaml) - cross-platform compatibility
#   - Shell scripts (.sh) - Unix requirement
#   - .github/** ALL files - GitHub Actions run on Linux, Dependabot commits LF
#     This includes .github/*.md files (copilot-instructions.md, etc.)
#
# The normalize-eol.ps1 script (step 1) handles this automatically.
# Prettier uses .prettierrc.json overrides for LF files.
# If you see EOL-related CI failures, run: npm run fix:eol
# ============================================================================

# Prettier format and re-add using retry logic to handle index.lock contention
if [ ${#MD_FILES_ARRAY[@]} -gt 0 ]; then
  npx --no-install prettier --write --log-level warn -- "${MD_FILES_ARRAY[@]}"
  # Verify formatting was successful before re-staging
  if ! npx --no-install prettier --check -- "${MD_FILES_ARRAY[@]}" >/dev/null 2>&1; then
    echo "Error: Prettier formatting verification failed for Markdown files." >&2
    exit 1
  fi
  # Use git_add_with_retry to handle concurrent git operations safely
  git_add_with_retry "${MD_FILES_ARRAY[@]}"
fi

if [ ${#JSON_FILES_ARRAY[@]} -gt 0 ]; then
  npx --no-install prettier --write --log-level warn -- "${JSON_FILES_ARRAY[@]}"
  # Verify formatting was successful before re-staging
  if ! npx --no-install prettier --check -- "${JSON_FILES_ARRAY[@]}" >/dev/null 2>&1; then
    echo "Error: Prettier formatting verification failed for JSON files." >&2
    exit 1
  fi
  # Use git_add_with_retry to handle concurrent git operations safely
  git_add_with_retry "${JSON_FILES_ARRAY[@]}"
fi

if [ ${#YAML_FILES_ARRAY[@]} -gt 0 ]; then
  npx --no-install prettier --write --log-level warn -- "${YAML_FILES_ARRAY[@]}"
  # Verify formatting was successful before re-staging
  if ! npx --no-install prettier --check -- "${YAML_FILES_ARRAY[@]}" >/dev/null 2>&1; then
    echo "Error: Prettier formatting verification failed for YAML files." >&2
    exit 1
  fi
  # Use git_add_with_retry to handle concurrent git operations safely
  git_add_with_retry "${YAML_FILES_ARRAY[@]}"
fi

if [ ${#JS_FILES_ARRAY[@]} -gt 0 ]; then
  npx --no-install prettier --write --log-level warn -- "${JS_FILES_ARRAY[@]}"
  # Verify formatting was successful before re-staging
  if ! npx --no-install prettier --check -- "${JS_FILES_ARRAY[@]}" >/dev/null 2>&1; then
    echo "Error: Prettier formatting verification failed for JS files." >&2
    exit 1
  fi
  # Use git_add_with_retry to handle concurrent git operations safely
  git_add_with_retry "${JS_FILES_ARRAY[@]}"
fi

# 6) Format staged C# files with CSharpier (if available) and re-stage
if [ ${#CS_FILES_ARRAY[@]} -gt 0 ]; then
  if command -v pwsh >/dev/null 2>&1; then
    pwsh -NoProfile -File scripts/format-staged-csharp.ps1
  elif command -v powershell >/dev/null 2>&1; then
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/format-staged-csharp.ps1
  else
    echo "PowerShell not found. Skipping CSharpier formatting." >&2
  fi
fi

# 7) Markdown lint for staged Markdown files
if [ ${#MD_FILES_ARRAY[@]} -gt 0 ]; then
  # First, auto-fix what can be fixed
  npx --no-install markdownlint --fix --config .markdownlint.json --ignore-path .markdownlintignore -- "${MD_FILES_ARRAY[@]}" || true
  # Re-stage the fixed files
  git_add_with_retry "${MD_FILES_ARRAY[@]}"
  # Then run markdownlint again to catch any remaining unfixable issues
  npx --no-install markdownlint --config .markdownlint.json --ignore-path .markdownlintignore -- "${MD_FILES_ARRAY[@]}"
fi

# 8) YAML lint on staged YAML files
if [ ${#YAML_FILES_ARRAY[@]} -gt 0 ]; then
  if command -v yamllint >/dev/null 2>&1; then
    yamllint -c .yamllint.yaml -- "${YAML_FILES_ARRAY[@]}"
  else
    echo "yamllint not found; skipping YAML lint (run 'npm run verify:tools' to check setup)." >&2
  fi
fi

# 9) Spell check staged files with cspell
# Runs on markdown, code, and config files
if [ ${#SPELL_FILES_ARRAY[@]} -gt 0 ]; then
  if npx --no-install cspell --version >/dev/null 2>&1; then
    echo "Running spell check on staged files..."
    # Use a temp file to avoid Windows command length limits with large staged sets
    SPELL_FILE_LIST="$(mktemp 2>/dev/null || true)"
    if [ -z "$SPELL_FILE_LIST" ]; then
      echo "Error: Failed to create temporary file for spell check file list." >&2
      exit 1
    fi

    trap 'rm -f "$SPELL_FILE_LIST"' EXIT
    printf '%s\n' "${SPELL_FILES_ARRAY[@]}" > "$SPELL_FILE_LIST"
    # Use --no-must-find-files to avoid errors when files are filtered by cspell config
    npx --no-install cspell lint --no-must-find-files --no-progress --file-list "$SPELL_FILE_LIST" || {
      echo "Spell check failed. Fix spelling errors or add words to cspell.json." >&2
      exit 1
    }
  else
    echo "cspell not found; skipping spell check (run 'npm install' to install)." >&2
  fi
fi

# 10) Validate LLM instructions if .llm/ files are staged
LLM_FILES_ARRAY=()
for file in "${STAGED_FILES_ARRAY[@]}"; do
    case "$file" in
        .llm/*)
            LLM_FILES_ARRAY+=("$file")
            ;;
    esac
done

if [ ${#LLM_FILES_ARRAY[@]} -gt 0 ]; then
  echo "Validating LLM instructions..."
  if command -v pwsh >/dev/null 2>&1; then
    pwsh -NoProfile -File scripts/lint-llm-instructions.ps1 || {
      echo "LLM instructions validation failed. Run 'pwsh -NoProfile -File scripts/lint-llm-instructions.ps1 -Fix' to auto-fix." >&2
      exit 1
    }
  elif command -v powershell >/dev/null 2>&1; then
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/lint-llm-instructions.ps1 || {
      echo "LLM instructions validation failed. Run 'powershell -NoProfile -File scripts/lint-llm-instructions.ps1 -Fix' to auto-fix." >&2
      exit 1
    }
  else
    echo "PowerShell not found. Skipping LLM instructions validation." >&2
  fi
fi

# 11) Check skill file sizes if .llm/skills/*.md files are staged
LLM_SKILLS_ARRAY=()
for file in "${STAGED_FILES_ARRAY[@]}"; do
    case "$file" in
        .llm/skills/*.md)
            LLM_SKILLS_ARRAY+=("$file")
            ;;
    esac
done

if [ ${#LLM_SKILLS_ARRAY[@]} -gt 0 ]; then
  echo "Checking skill file sizes..."
  if command -v pwsh >/dev/null 2>&1; then
    pwsh -NoProfile -File scripts/lint-skill-sizes.ps1 || {
      echo "Skill file size check failed. Some files exceed 500 lines and must be split." >&2
      exit 1
    }
  elif command -v powershell >/dev/null 2>&1; then
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/lint-skill-sizes.ps1 || {
      echo "Skill file size check failed. Some files exceed 500 lines and must be split." >&2
      exit 1
    }
  else
    echo "PowerShell not found. Skipping skill file size check." >&2
  fi
fi

# 12) Run test linter on staged test files
# Checks for Unity object lifecycle issues (UNH001-UNH003), naming conventions (UNH004), null checks (UNH005)
TEST_FILES_ARRAY=()
for file in "${STAGED_FILES_ARRAY[@]}"; do
    case "$file" in
        Tests/*.cs)
            TEST_FILES_ARRAY+=("$file")
            ;;
    esac
done

# Auto-fix Unity null assertions (Assert.IsNotNull/IsNull) in staged test files before linting
if [ ${#TEST_FILES_ARRAY[@]} -gt 0 ]; then
  echo "Auto-fixing Unity null assertions in staged tests..."
  if command -v pwsh >/dev/null 2>&1; then
    pwsh -NoProfile -File scripts/lint-tests.ps1 -FixNullChecks -Paths "${TEST_FILES_ARRAY[@]}"
  elif command -v powershell >/dev/null 2>&1; then
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/lint-tests.ps1 -FixNullChecks -Paths "${TEST_FILES_ARRAY[@]}"
  else
    echo "PowerShell not found. Skipping test auto-fixes." >&2
  fi

  # Reformat and re-stage test files after auto-fixes
  if command -v pwsh >/dev/null 2>&1; then
    pwsh -NoProfile -File scripts/format-staged-csharp.ps1 "${TEST_FILES_ARRAY[@]}"
  elif command -v powershell >/dev/null 2>&1; then
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/format-staged-csharp.ps1 "${TEST_FILES_ARRAY[@]}"
  fi
fi

if [ ${#TEST_FILES_ARRAY[@]} -gt 0 ]; then
  echo "Running test linter on staged test files..."
  if command -v pwsh >/dev/null 2>&1; then
    pwsh -NoProfile -File scripts/lint-tests.ps1 -Paths "${TEST_FILES_ARRAY[@]}" || {
      echo "" >&2
      echo "=== Test lint failed ===" >&2
      echo "Fix the issues above or add // UNH-SUPPRESS comments for valid exceptions." >&2
      echo "For naming convention errors (UNH004):" >&2
      echo "  - Use PascalCase or dot notation in TestName/SetName (e.g., 'Input.Null.ReturnsFalse')" >&2
      echo "  - Use PascalCase for TestCaseSource method names (e.g., 'EdgeCaseTestData')" >&2
      echo "For null check errors (UNH005):" >&2
      echo "  - Use Assert.IsTrue(x != null) instead of Assert.IsNotNull(x)" >&2
      echo "  - Use Assert.IsTrue(x == null) instead of Assert.IsNull(x)" >&2
      echo "  - Why: Unity's == operator performs special 'fake null' checking" >&2
      echo "Auto-fix null asserts: pwsh -NoProfile -File scripts/lint-tests.ps1 -FixNullChecks -Paths <test files>" >&2
      echo "" >&2
      exit 1
    }
  elif command -v powershell >/dev/null 2>&1; then
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/lint-tests.ps1 -Paths "${TEST_FILES_ARRAY[@]}" || {
      echo "" >&2
      echo "=== Test lint failed ===" >&2
      echo "Fix the issues above or add // UNH-SUPPRESS comments for valid exceptions." >&2
      echo "For naming convention errors (UNH004):" >&2
      echo "  - Use PascalCase or dot notation in TestName/SetName (e.g., 'Input.Null.ReturnsFalse')" >&2
      echo "  - Use PascalCase for TestCaseSource method names (e.g., 'EdgeCaseTestData')" >&2
      echo "For null check errors (UNH005):" >&2
      echo "  - Use Assert.IsTrue(x != null) instead of Assert.IsNotNull(x)" >&2
      echo "  - Use Assert.IsTrue(x == null) instead of Assert.IsNull(x)" >&2
      echo "  - Why: Unity's == operator performs special 'fake null' checking" >&2
      echo "Auto-fix null asserts: powershell -NoProfile -ExecutionPolicy Bypass -File scripts/lint-tests.ps1 -FixNullChecks -Paths <test files>" >&2
      echo "" >&2
      exit 1
    }
  else
    echo "PowerShell not found. Skipping test linter." >&2
  fi
fi

# 13) Check for forbidden #region/#endregion directives in C# files
# Regions are forbidden in this codebase - see .llm/skills/no-regions.md
if [ ${#CS_FILES_ARRAY[@]} -gt 0 ]; then
  echo "Checking for forbidden #region directives..."
  REGION_VIOLATIONS=""
  for file in "${CS_FILES_ARRAY[@]}"; do
    # Use grep to find #region or #endregion (case-insensitive for robustness)
    # Match lines that have #region or #endregion as preprocessor directives
    MATCHES=$(grep -n -i '^\s*#\s*region\|^\s*#\s*endregion' "$file" 2>/dev/null || true)
    if [ -n "$MATCHES" ]; then
      while IFS= read -r match; do
        REGION_VIOLATIONS="${REGION_VIOLATIONS}  ${file}:${match}"$'\n'
      done <<< "$MATCHES"
    fi
  done

  if [ -n "$REGION_VIOLATIONS" ]; then
    echo "" >&2
    echo "=== Error: C# regions (#region/#endregion) are forbidden ===" >&2
    echo "The following files contain regions:" >&2
    echo "$REGION_VIOLATIONS" >&2
    echo "Remove all #region and #endregion directives before committing." >&2
    echo "See .llm/skills/no-regions.md for guidance on code organization alternatives." >&2
    echo "" >&2
    exit 1
  fi
fi

# 14) Lint property drawers for multi-object editing issues (warnings only, non-blocking)
DRAWER_FILES_ARRAY=()
for file in "${CS_FILES_ARRAY[@]}"; do
    case "$file" in
        *Drawer.cs)
            DRAWER_FILES_ARRAY+=("$file")
            ;;
    esac
done

if [ ${#DRAWER_FILES_ARRAY[@]} -gt 0 ]; then
  echo "Checking property drawers for multi-object editing issues..."
  if command -v pwsh >/dev/null 2>&1; then
    pwsh -NoProfile -File scripts/lint-drawer-multiobject.ps1 -Paths "${DRAWER_FILES_ARRAY[@]}" || true
  elif command -v powershell >/dev/null 2>&1; then
    powershell -NoProfile -ExecutionPolicy Bypass -File scripts/lint-drawer-multiobject.ps1 -Paths "${DRAWER_FILES_ARRAY[@]}" || true
  else
    echo "PowerShell not found. Skipping drawer multi-object lint." >&2
  fi
fi
